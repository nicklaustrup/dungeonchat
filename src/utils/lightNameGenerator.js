/**
 * Light Name Generator Utility
 * Auto-generates sequential names for lights based on their type
 * Examples: "Torch 1", "Torch 2", "Lantern 1", etc.
 */

/**
 * Generate a sequential name for a light based on its type and existing lights
 * @param {string} lightType - The type/preset of the light (torch, lantern, candle, etc.)
 * @param {Array} existingLights - Array of existing light objects with names
 * @returns {string} - Generated name (e.g., "Torch 3")
 */
export function generateLightName(lightType, existingLights = []) {
  // Map light types to readable display names
  const typeNameMap = {
    torch: 'Torch',
    lantern: 'Lantern',
    candle: 'Candle',
    campfire: 'Campfire',
    brazier: 'Brazier',
    lightSpell: 'Light',
    daylightSpell: 'Daylight',
    magicalBlue: 'Blue Light',
    magicalPurple: 'Purple Light',
    magicalGreen: 'Green Light',
    magicalRed: 'Red Light',
    custom: 'Light'
  };

  // Get the base name for this light type
  const baseName = typeNameMap[lightType] || 'Light';

  // Find all lights with the same base name pattern
  // Pattern: "Torch 1", "Torch 2", etc.
  const pattern = new RegExp(`^${escapeRegex(baseName)}\\s+(\\d+)$`);
  
  const existingNumbers = existingLights
    .map(light => {
      if (!light.name) return null;
      const match = light.name.match(pattern);
      return match ? parseInt(match[1], 10) : null;
    })
    .filter(num => num !== null && !isNaN(num));

  // Find the highest number used
  const maxNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) : 0;
  
  // Return the next sequential number
  const nextNumber = maxNumber + 1;
  
  return `${baseName} ${nextNumber}`;
}

/**
 * Extract the light type from a light name
 * Used to determine which lights are of the same "family"
 * @param {string} name - The light name (e.g., "Torch 3")
 * @returns {string|null} - The base type name (e.g., "Torch") or null
 */
export function extractLightBaseName(name) {
  if (!name || typeof name !== 'string') return null;
  
  // Match pattern like "Torch 3" and extract "Torch"
  const match = name.match(/^(.+?)\s+\d+$/);
  return match ? match[1] : null;
}

/**
 * Check if a light name follows the auto-generated pattern
 * @param {string} name - The light name to check
 * @returns {boolean} - True if it matches the pattern "Name #"
 */
export function isAutoGeneratedName(name) {
  if (!name || typeof name !== 'string') return false;
  return /^.+\s+\d+$/.test(name);
}

/**
 * Get the next available number for a specific light type
 * @param {string} baseName - The base name (e.g., "Torch")
 * @param {Array} existingLights - Array of existing light objects
 * @returns {number} - The next available number
 */
export function getNextAvailableNumber(baseName, existingLights = []) {
  const pattern = new RegExp(`^${escapeRegex(baseName)}\\s+(\\d+)$`);
  
  const existingNumbers = existingLights
    .map(light => {
      if (!light.name) return null;
      const match = light.name.match(pattern);
      return match ? parseInt(match[1], 10) : null;
    })
    .filter(num => num !== null && !isNaN(num));

  return existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
}

/**
 * Escape special regex characters in a string
 * @param {string} str - String to escape
 * @returns {string} - Escaped string safe for use in RegExp
 */
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Generate a suggested name for editing
 * If the current name is auto-generated, increment it
 * Otherwise, return a new auto-generated name
 * @param {string} currentName - The current light name
 * @param {string} lightType - The light type
 * @param {Array} existingLights - Array of existing lights
 * @returns {string} - Suggested name
 */
export function suggestLightName(currentName, lightType, existingLights = []) {
  // If no current name or it's auto-generated, generate a new one
  if (!currentName || isAutoGeneratedName(currentName)) {
    return generateLightName(lightType, existingLights);
  }
  
  // Keep the custom name
  return currentName;
}
